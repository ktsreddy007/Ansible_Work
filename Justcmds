#To execute yamllint we need to have it installed
sudo apt install yamllint

#Yamllint command to validate the YAML file syntax
yamllint file.yml

#command to convert yml file to json via python
python3 -c 'import sys, yaml, json; json.dump(yaml.load(sys.stdin, Loader=yaml.FullLoader), sys.stdout, indent=4)' < hosts.yml > hosts.json

#Ansible command to check ansible verison and config data
ansible --version
  #Output to be as below
ansible@ubuntu-c:~/AnsiPro$ ansible --version
ansible [core 2.17.4]
  config file = /home/ansible/AnsiPro/ansible.cfg
  configured module search path = ['/home/ansible/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules']
  ansible python module location = /usr/local/lib/python3.10/dist-packages/ansible
  ansible collection location = /home/ansible/.ansible/collections:/usr/share/ansible/collections
  executable location = /usr/local/bin/ansible
  python version = 3.10.12 (main, Jul 29 2024, 16:56:48) [GCC 11.4.0] (/usr/bin/python3)
  jinja version = 3.1.4
  libyaml = True

#Ansible command to know the hosts based on our hosts file code
ansible all -i /home/ansible/AnsiPro/inventory/hosts.yml --list-hosts
#or
ansible all --list-hosts

#Ansible command to ping the slaves of ansible with group name called linux and all
ansible  all -m ping -o
#or
ansible  linux -m ping -o

#Ansible command to excute the playbook with particular invetory and single host named centos1
ansible-playbook -i /home/ansible/AnsiPro/inventory/hosts.yml motd_playbook.yaml

#Ansible command to pass the varible value when executing the plabook
ansible-playbook  xtra-vars.yaml -e 'motd="This is teja\n"'

#Ansible command to know the time taken to run the plabook
time ansible-playbook  motd_playbook.yaml

#Ansible command to know the hostvars of particular slave & particular parameter
ansible centos1 -m debug -a "var=ansible_hostname"

#Ansible command to know the particular network facts data related to remotehost machine
ansible centos1 -m setup -a 'gather_subsets=network' | more

#Ansible commmand to get & restrict for Network related data and other facts not to display using !min and !all 
ansible centos1 -m setup -a 'gather_subsets=!all,!min,network' | more 

#Ansible Jinja2 template language control structures syntax
1) if Statement Syntax

{% if condition %}
  # Do something if the condition is true
{% elif another_condition %}
  # Do something if the another_condition is true
{% else %}
  # Do something if the condition is false
{% endif %}

Example :
{% if ansible_facts['distribution'] == 'Ubuntu' %}
  apt:
    name: nginx
    state: present
{% else %}
  yum:
    name: nginx
    state: present
{% endif %}

2) Loops (for loop Syntax)
 
{% for item in items %}
  # Do something for each item in the items list
{% endfor %}

Example:
{% for user in users %}
  name: "{{ user }}"
  shell: /bin/bash
{% endfor %}

2a) for loop syntax with loop.index and loop.length

{% for item in items %}
  Item {{ loop.index }} of {{ loop.length }}: {{ item }}
{% endfor %}

3) Variable Lookup and Default Values

Default filter
{{ variable | default('default_value') }}

Example - {{ some_variable | default('not set') }}

Defined test

{% if some_variable is defined %}
  # Variable exists
{% else %}
  # Variable does not exist
{% endif %}

4) other template files including

{% include 'file_name.j2' %}

#To run the playbook along with Ansible vault password
ansible-playbook playbook.yml --ask-vault-pass

#Error handling mechanisms
  Mechanism	          Purpose
ignore_errors---------Skip failure, continue play
failed_when-----------Custom failure conditions
changed_when----------Custom "changed" conditions
block/rescue----------Try/catch logic
always----------------Always runs, even on failure
max_fail_percentage---Limit host failures allowed
any_errors_fatal------Fail entire play on one host failure
fail module-----------Intentionally fail with a message

#If playbooks fails midway we can follow below apporaoches
1) Check output logs by rerunning
  ansible-playbook urplaybook.yaml -i inventory/hosts
                     or
  ansible-playbook urplaybook -i inventory/hosts -vvv
2) If its a transient issue add retries & delay
    retries : 5
    delay : 10
3) limit to single host for faster debugging
   ansible-playbook urplaybook.yaml -i inventory/hosts --limit hostname
                 or
   ansible-playbook urplaybook.yaml -i inventory/hosts --limit 'web*' 
4) handling recovery via below appraches
  a) Re-run the playbook (if idempotent)
  b) Start from a specific task (after fixing issue)
      ansible-playbook urplaybook.yaml -i inventory/hosts --start-at-task="Install software"
  c) use try catch mechanism like block ,rescue, always
5) Post mortem improvements
   a) Use failed_when and changed_when
   b) Add logging and debug info     

#Dynamic Inventory Installation Steps for AWS
#Step 1
Below cmd to check the collection is present in ansible package or not
ansible-galaxy collection list --------check amazon.aws is present or not
------------------------------------------------------------------------------
#Step 2
Now install it using below command 
ansible-galaxy collection install amazon.aws
-----------------------------------------------------------------------------
#Step 3 Prerequiste
To exacute above inventory we need to have below installed on control node
python >=3.6
boto3 >= 1.28.0
botocore >=1.31.0
###To check above are prerequiste version
python3 -m pip --version  ## for pip
python3 --version ####for python
python3 -m pip show boto3 botocore  ####for boto3 & botocore
### If not present it will not show version in that case install them via pip and curl
sudo apt install -y curl  #cmd to install curl if not present
sudo curl -O https://bootstrap.pypa.io/get-pip.py
sudo python3 get-pip.py                           #cmd to install pip if not present
### Now install boto3 & boto core
python3 -m pip install --upgrade 'boto3>=1.28.0' 'botocore>=1.31.0'
============================================================================================
#Command to create collection
ansible-galaxy collection init mynamespace.mycollection
#Command to build the collection
ansible-galaxy collection build
#Above cmd creates a .tar.gz file as below
mynamespace-mycollection-1.0.0.tar.gz
#Insatall above collection wrapped in tar locally
ansible-galaxy collection install mynamespace-mycollection-1.0.0.tar.gz
#Run the playbook from above
ansible-playbook -i inventory.ini playbooks/install_ngnix.yml

Note : Ansible creates only the standard minimal collection structure. This does not include playbooks/ or tests/ directories by default â€” you have to add them manually if you need them.
============================================================================================
#command to publish collection via Ansible Automation hub 
ansible-galaxy collection publish your_namespace-your_collection-<version>.tar.gz \
  --server https://automation-hub.your-company.com/api/galaxy/ \
  --api-key <YOUR_AUTOMATION_HUB_API_TOKEN>
=========================================================================================
#Below is the process to build , publish collection via Ansible Galaxy
ansible-galaxy collection publish your_namespace-your_collection-<version>.tar.gz \
  --server https://automation-hub.your-company.com/api/galaxy/ \
  --api-key <YOUR_AUTOMATION_HUB_API_TOKEN>
#In above cmd we can ignore server and apikey as they are kept in ansible.cfg
ansible-galaxy collection build
ansible-galaxy collection publish your_namespace-your_collection-<version>.tar.gz
=======================================================================================
#cmd to initialize the collection freshly
ansible-galaxy collection init my_namespace.my_collection
#cmd to install the collection from galaxy and automationhub
ansible-galaxy collection install my_namespace.my_collection
#cmd to delete the collection 
ansible-galaxy collection delete my_namespace.my_collection
#cmd to install collection if requirement file is present
ansible-galaxy collection install -r requirements.yml
#cmd to install roles from requirments file
ansible-galaxy install -r requirements.yml
